{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sameh\\\\OneDrive\\\\Documents\\\\Desktop\\\\Horloge2\\\\travail22025\\\\src\\\\JeuxHorloge\\\\Horloge.tsx\",\n  _s = $RefreshSig$();\n/* import React, { useEffect, useState } from \"react\";\nimport PileHorloge from \"./PileHorloge\";\nimport { Deck } from \"./Deck\";\nimport { EtatApp, CarteH } from \"./Types\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nconst Horloge: React.FC = () => {\n  const [etat, setEtat] = useState<EtatApp>({\n    piles: Array(12).fill({ cartes: [] }),\n    pileCentrale: { cartes: [] },\n    paquet: [],\n    cartesRevelees: [],\n  });\n\n  // Utilisation de useEffect pour récupérer les cartes via l'API\n  useEffect(() => {\n    const initialiserJeu = async () => {\n      const nouveauPaquet = await Deck.creerPaquet();\n      setEtat((ancienEtat) => ({ ...ancienEtat, paquet: nouveauPaquet }));\n      distribuerCartes(nouveauPaquet);\n    };\n\n    initialiserJeu();\n  }, []); // Vide le tableau de dépendances pour que cela se fasse une seule fois au démarrage\n\n  const distribuerCartes = (paquet: string[]) => {\n    const piles: { cartes: CarteH[] }[] = Array(12).fill({ cartes: [] }).map(() => ({ cartes: [] }));\n    \n    const pileCentrale: { cartes: CarteH[] } = {\n      cartes: [\n        { code: paquet[0], image: `https://deckofcardsapi.com/static/img/${paquet[0]}.png` },\n      ],\n    };\n  \n    for (let i = 1; i < paquet.length; i++) {\n      const indexPile = i % 12;\n      piles[indexPile].cartes.push({\n        code: paquet[i],\n        image: `https://deckofcardsapi.com/static/img/${paquet[i]}.png`,\n      });\n    }\n  \n    setEtat((ancienEtat) => ({\n      ...ancienEtat,\n      piles,\n      pileCentrale,  // Correcte maintenant la structure de pileCentrale\n    }));\n  };\n  \n\n  function deplacerCarte(carte: CarteH, indexPile: number) {\n    const nouvellesPilesCopy = [...etat.piles]; // Crée une copie de l'état des piles\n\n    // Vérifie que l'élément à l'index spécifié est un tableau avant de l'itérer\n    if (Array.isArray(nouvellesPilesCopy[indexPile].cartes)) {\n      nouvellesPilesCopy[indexPile].cartes = [\n        ...nouvellesPilesCopy[indexPile].cartes,\n        carte,\n      ]; // Ajoute la carte à la pile\n    } else {\n      console.error(\"L'élément à l'index \" + indexPile + \" n'est pas un tableau.\");\n    }\n\n    // Met à jour l'état avec les nouvelles piles\n    setEtat((ancienEtat) => ({ ...ancienEtat, piles: nouvellesPilesCopy }));\n  }\n\n  return (\n    <div className=\"container text-center mt-5\">\n      <h1>Clock Solitaire</h1>\n      <div className=\"row justify-content-center mt-4\">\n        {etat.piles.map((pile, index) => (\n          <div className=\"col-2\" key={index}>\n            <PileHorloge\n              pile={pile.cartes} // Passe des objets CarteH ici\n              indexPile={index}\n              deplacerCarte={deplacerCarte}\n              centrale={false}\n            />\n          </div>\n        ))}\n        <div className=\"col-2\">\n          <PileHorloge\n            pile={etat.pileCentrale.cartes} // Passe des objets CarteH ici\n            indexPile={-1}\n            deplacerCarte={deplacerCarte}\n            centrale={true}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Horloge;\n */\nimport React, { useState, useEffect } from \"react\";\nimport PileHorloge from \"./PileHorloge\";\nimport { Deck } from \"./Deck\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Horloge = () => {\n  _s();\n  const [etat, setEtat] = useState({\n    piles: Array(12).fill(null).map(() => ({\n      cartes: []\n    })),\n    // 12 piles vides\n    pileCentrale: {\n      cartes: []\n    },\n    // Pile centrale vide\n    paquet: [],\n    // Paquet vide\n    cartesRevelees: [],\n    // Aucune carte révélée au départ\n    pileCibleIndex: -1\n  });\n  useEffect(() => {\n    const initialiserJeu = async () => {\n      const nouveauPaquet = await Deck.creerPaquet();\n      setEtat(ancienEtat => ({\n        ...ancienEtat,\n        paquet: nouveauPaquet\n      }));\n      distribuerCartes(nouveauPaquet);\n    };\n    initialiserJeu();\n  }, []);\n  const distribuerCartes = paquet => {\n    const piles = Array(12).fill(null).map(() => ({\n      cartes: []\n    }));\n    const pileCentrale = {\n      cartes: []\n    };\n    let indexCarte = 0;\n\n    // Mélanger le paquet pour distribuer les cartes de manière aléatoire\n    paquet.sort(() => Math.random() - 0.5);\n\n    // Distribution des 12 piles en cercle (4 cartes par pile, face cachée)\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 12; j++) {\n        piles[j].cartes.push({\n          code: paquet[indexCarte].code,\n          // Correct ici\n          image: paquet[indexCarte].image,\n          // Utiliser directement l'image de l'objet\n          faceVisible: false,\n          // Toutes les cartes commencent face cachée\n          value: paquet[indexCarte].value\n        });\n        indexCarte++;\n      }\n    }\n\n    // Distribution de la pile centrale (4 cartes, face cachée)\n    for (let i = 0; i < 4; i++) {\n      pileCentrale.cartes.push({\n        code: paquet[indexCarte].code,\n        // Correct ici\n        image: paquet[indexCarte].image,\n        // Utiliser l'image de l'objet\n        faceVisible: false,\n        value: paquet[indexCarte].value\n      });\n      indexCarte++;\n    }\n\n    // Choisir une carte au hasard parmi les 4 premières cartes de la pile centrale pour la rendre visible\n    const indexCarteVisible = 3; //Math.floor(Math.random() * 4);\n    pileCentrale.cartes[indexCarteVisible].faceVisible = true;\n    console.log('originalpilecentrale', pileCentrale.cartes);\n    // Mettre à jour l'état avec les nouvelles piles, la pile centrale et la carte révélée\n    setEtat(ancienEtat => ({\n      ...ancienEtat,\n      piles,\n      pileCentrale,\n      cartesRevelees: [pileCentrale.cartes[indexCarteVisible]] // Ajouter la carte révélée\n    }));\n  };\n\n  // Fonction pour déplacer une carte dans la pile correspondante\n  /* const deplacerCarte = (carte: CarteH, indexPile: number) => {\n    console.log(\"index de la pile est \"+indexPile);\n    const nouvellesPiles = [...etat.piles];\n    const pileCentrale = [etat.pileCentrale];\n    console.log('pileCentrale',pileCentrale);\n    console.log('nouvellesPiles',nouvellesPiles);\n    console.log(carte);\n    // Vérifier si la carte peut être déplacée (par exemple, si elle est face visible)\n  /*    if (!carte.faceVisible) {\n      alert(`Vous ne pouvez pas déplacer une carte face cachée ! ${indexPile}`);\n      return;\n    } */\n\n  // Ajouter la carte à la pile correspondante et la rendre face visible\n  /* nouvellesPiles[indexPile].cartes.push({ ...carte, faceVisible: true });\n    // Mettre à jour l'état avec les nouvelles piles et la carte révélée\n   setEtat((ancienEtat) => ({\n     ...ancienEtat,\n     piles: nouvellesPiles,\n     cartesRevelees: [...ancienEtat.cartesRevelees, carte], // Ajouter la carte aux cartes révélées\n   }));\n  }; */\n  const deplacerCarte = () => {\n    setEtat(ancienEtat => {\n      let nouvellesPiles = [...ancienEtat.piles];\n      let nouvellePileCentrale = {\n        ...ancienEtat.pileCentrale\n      };\n      let carteCouranteADeplacer = nouvellesPiles[ancienEtat.pileCibleIndex].cartes.find(c => c.faceVisible) || null;\n      if (ancienEtat.pileCibleIndex === -1) {\n        carteCouranteADeplacer = nouvellePileCentrale.cartes.find(c => c.faceVisible) || null;\n      }\n      if (!carteCouranteADeplacer) {\n        console.log(\"Aucune carte visible à déplacer !\");\n        return ancienEtat;\n      }\n      let indexPileDestination = obtenirPileCorrespondante(carteCouranteADeplacer);\n      if (indexPileDestination === -1) {\n        console.log(\"Erreur : Impossible de trouver la pile correspondante !\");\n        return ancienEtat;\n      }\n      nouvellesPiles[indexPileDestination].cartes.unshift({\n        ...carteCouranteADeplacer,\n        faceVisible: true\n      });\n      nouvellePileCentrale.cartes = nouvellePileCentrale.cartes.filter(c => c.code !== carteCouranteADeplacer.code);\n      const pileCible = nouvellesPiles[indexPileDestination];\n      pileCible.cartes.forEach((carte, index) => {\n        carte.faceVisible = index === 0 || index === 4;\n      });\n      return {\n        ...ancienEtat,\n        piles: nouvellesPiles,\n        pileCentrale: nouvellePileCentrale,\n        cartesRevelees: [...ancienEtat.cartesRevelees, carteCouranteADeplacer],\n        pileCibleIndex: indexPileDestination // Enregistrer l'index de la pile cible\n      };\n    });\n  };\n  const deplacerCarteSuivante = () => {\n    setEtat(ancienEtat => {\n      let nouvellesPiles = [...ancienEtat.piles];\n      const pileCible = nouvellesPiles[ancienEtat.pileCibleIndex];\n      const carteVisible = pileCible.cartes.find(c => c.faceVisible);\n      if (!carteVisible) {\n        console.log(\"Aucune carte visible à déplacer dans la pile cible !\");\n        return ancienEtat;\n      }\n      let indexPileDestination = obtenirPileCorrespondante(carteVisible);\n      if (indexPileDestination === -1) {\n        console.log(\"Erreur : Impossible de trouver la pile correspondante pour la carte visible !\");\n        return ancienEtat;\n      }\n      nouvellesPiles[indexPileDestination].cartes.unshift({\n        ...carteVisible,\n        faceVisible: true\n      });\n      pileCible.cartes = pileCible.cartes.filter(c => c.code !== carteVisible.code);\n      return {\n        ...ancienEtat,\n        piles: nouvellesPiles\n      };\n    });\n  };\n\n  // Fonction pour obtenir l'index de la pile correspondant à une carte\n  const obtenirPileCorrespondante = carte => {\n    var _rangs$valeurCarte, _rangs$valeurCarte2;\n    const valeurCarte = carte.value; // Extrait la valeur de la carte (par exemple \"2\", \"JACK\", etc.)\n    console.log(valeurCarte);\n    const rangs = {\n      \"2\": 2,\n      \"3\": 3,\n      \"4\": 4,\n      \"5\": 5,\n      \"6\": 6,\n      \"7\": 7,\n      \"8\": 8,\n      \"9\": 9,\n      \"10\": 10,\n      \"JACK\": 11,\n      \"QUEEN\": 0,\n      \"KING\": -1,\n      \"ACE\": 1\n    };\n    console.log((_rangs$valeurCarte = rangs[valeurCarte]) !== null && _rangs$valeurCarte !== void 0 ? _rangs$valeurCarte : -1);\n    return (_rangs$valeurCarte2 = rangs[valeurCarte]) !== null && _rangs$valeurCarte2 !== void 0 ? _rangs$valeurCarte2 : -1; // Retourne l'index de la pile correspondant au rang\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container text-center mt-5\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Clock Solitaire\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 303,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"position-relative\",\n      style: {\n        width: \"500px\",\n        height: \"500px\",\n        margin: \"0 auto\"\n      },\n      children: [etat.piles.map((pile, index) => {\n        const angle = (index - 3) * 30 * (Math.PI / 180);\n        const radius = 180;\n        const x = 250 + radius * Math.cos(angle);\n        const y = 250 + radius * Math.sin(angle);\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"position-absolute\",\n          style: {\n            left: `${x}px`,\n            top: `${y}px`,\n            transform: \"translate(-50%, -50%)\"\n          },\n          children: /*#__PURE__*/_jsxDEV(PileHorloge, {\n            pile: pile.cartes,\n            indexPile: index,\n            deplacerCarte: deplacerCarte,\n            centrale: false\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 323,\n            columnNumber: 15\n          }, this)\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 314,\n          columnNumber: 13\n        }, this);\n      }), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"position-absolute top-50 start-50 translate-middle\",\n        children: /*#__PURE__*/_jsxDEV(PileHorloge, {\n          pile: etat.pileCentrale.cartes,\n          indexPile: -1,\n          deplacerCarte: deplacerCarte,\n          centrale: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 333,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 332,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 304,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 302,\n    columnNumber: 5\n  }, this);\n};\n_s(Horloge, \"yzf0+tgmuBju88rmjc+unyB7f/4=\");\n_c = Horloge;\nexport default Horloge;\nvar _c;\n$RefreshReg$(_c, \"Horloge\");","map":{"version":3,"names":["React","useState","useEffect","PileHorloge","Deck","jsxDEV","_jsxDEV","Horloge","_s","etat","setEtat","piles","Array","fill","map","cartes","pileCentrale","paquet","cartesRevelees","pileCibleIndex","initialiserJeu","nouveauPaquet","creerPaquet","ancienEtat","distribuerCartes","indexCarte","sort","Math","random","i","j","push","code","image","faceVisible","value","indexCarteVisible","console","log","deplacerCarte","nouvellesPiles","nouvellePileCentrale","carteCouranteADeplacer","find","c","indexPileDestination","obtenirPileCorrespondante","unshift","filter","pileCible","forEach","carte","index","deplacerCarteSuivante","carteVisible","_rangs$valeurCarte","_rangs$valeurCarte2","valeurCarte","rangs","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","width","height","margin","pile","angle","PI","radius","x","cos","y","sin","left","top","transform","indexPile","centrale","_c","$RefreshReg$"],"sources":["C:/Users/sameh/OneDrive/Documents/Desktop/Horloge2/travail22025/src/JeuxHorloge/Horloge.tsx"],"sourcesContent":["/* import React, { useEffect, useState } from \"react\";\nimport PileHorloge from \"./PileHorloge\";\nimport { Deck } from \"./Deck\";\nimport { EtatApp, CarteH } from \"./Types\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nconst Horloge: React.FC = () => {\n  const [etat, setEtat] = useState<EtatApp>({\n    piles: Array(12).fill({ cartes: [] }),\n    pileCentrale: { cartes: [] },\n    paquet: [],\n    cartesRevelees: [],\n  });\n\n  // Utilisation de useEffect pour récupérer les cartes via l'API\n  useEffect(() => {\n    const initialiserJeu = async () => {\n      const nouveauPaquet = await Deck.creerPaquet();\n      setEtat((ancienEtat) => ({ ...ancienEtat, paquet: nouveauPaquet }));\n      distribuerCartes(nouveauPaquet);\n    };\n\n    initialiserJeu();\n  }, []); // Vide le tableau de dépendances pour que cela se fasse une seule fois au démarrage\n\n  const distribuerCartes = (paquet: string[]) => {\n    const piles: { cartes: CarteH[] }[] = Array(12).fill({ cartes: [] }).map(() => ({ cartes: [] }));\n    \n    const pileCentrale: { cartes: CarteH[] } = {\n      cartes: [\n        { code: paquet[0], image: `https://deckofcardsapi.com/static/img/${paquet[0]}.png` },\n      ],\n    };\n  \n    for (let i = 1; i < paquet.length; i++) {\n      const indexPile = i % 12;\n      piles[indexPile].cartes.push({\n        code: paquet[i],\n        image: `https://deckofcardsapi.com/static/img/${paquet[i]}.png`,\n      });\n    }\n  \n    setEtat((ancienEtat) => ({\n      ...ancienEtat,\n      piles,\n      pileCentrale,  // Correcte maintenant la structure de pileCentrale\n    }));\n  };\n  \n\n  function deplacerCarte(carte: CarteH, indexPile: number) {\n    const nouvellesPilesCopy = [...etat.piles]; // Crée une copie de l'état des piles\n\n    // Vérifie que l'élément à l'index spécifié est un tableau avant de l'itérer\n    if (Array.isArray(nouvellesPilesCopy[indexPile].cartes)) {\n      nouvellesPilesCopy[indexPile].cartes = [\n        ...nouvellesPilesCopy[indexPile].cartes,\n        carte,\n      ]; // Ajoute la carte à la pile\n    } else {\n      console.error(\"L'élément à l'index \" + indexPile + \" n'est pas un tableau.\");\n    }\n\n    // Met à jour l'état avec les nouvelles piles\n    setEtat((ancienEtat) => ({ ...ancienEtat, piles: nouvellesPilesCopy }));\n  }\n\n  return (\n    <div className=\"container text-center mt-5\">\n      <h1>Clock Solitaire</h1>\n      <div className=\"row justify-content-center mt-4\">\n        {etat.piles.map((pile, index) => (\n          <div className=\"col-2\" key={index}>\n            <PileHorloge\n              pile={pile.cartes} // Passe des objets CarteH ici\n              indexPile={index}\n              deplacerCarte={deplacerCarte}\n              centrale={false}\n            />\n          </div>\n        ))}\n        <div className=\"col-2\">\n          <PileHorloge\n            pile={etat.pileCentrale.cartes} // Passe des objets CarteH ici\n            indexPile={-1}\n            deplacerCarte={deplacerCarte}\n            centrale={true}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Horloge;\n */\nimport React, { useState, useEffect } from \"react\";\nimport PileHorloge from \"./PileHorloge\";\nimport { Deck } from \"./Deck\";\nimport { EtatApp, CarteH, Pile } from \"./Types\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nconst Horloge: React.FC = () => {\n  const [etat, setEtat] = useState<EtatApp>({\n    piles: Array(12).fill(null).map(() => ({ cartes: [] as CarteH[] })), // 12 piles vides\n    pileCentrale: { cartes: [] as CarteH[] }, // Pile centrale vide\n    paquet: [], // Paquet vide\n    cartesRevelees: [], // Aucune carte révélée au départ\n    pileCibleIndex: -1\n  });\n\n  useEffect(() => {\n    const initialiserJeu = async () => {\n      const nouveauPaquet = await Deck.creerPaquet();\n      setEtat((ancienEtat) => ({ ...ancienEtat, paquet: nouveauPaquet }));\n      distribuerCartes(nouveauPaquet);\n    };\n\n\n    initialiserJeu();\n  }, []);\n\n\n  const distribuerCartes = (paquet: CarteH[]) => {\n    const piles = Array(12).fill(null).map(() => ({ cartes: [] as CarteH[] }));\n\n    \n    const pileCentrale = { cartes: [] as CarteH[] };\n\n    let indexCarte = 0;\n\n    // Mélanger le paquet pour distribuer les cartes de manière aléatoire\n    paquet.sort(() => Math.random() - 0.5);\n\n\n    // Distribution des 12 piles en cercle (4 cartes par pile, face cachée)\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 12; j++) {\n        piles[j].cartes.push({\n          code: paquet[indexCarte].code, // Correct ici\n          image: paquet[indexCarte].image, // Utiliser directement l'image de l'objet\n          faceVisible: false, // Toutes les cartes commencent face cachée\n          value: paquet[indexCarte].value\n        });\n        indexCarte++;\n      }\n    }\n\n   \n\n    // Distribution de la pile centrale (4 cartes, face cachée)\n    for (let i = 0; i < 4; i++) {\n      pileCentrale.cartes.push({\n        code: paquet[indexCarte].code, // Correct ici\n        image: paquet[indexCarte].image, // Utiliser l'image de l'objet\n        faceVisible: false,\n        value: paquet[indexCarte].value\n      });\n      indexCarte++;\n    }\n\n    // Choisir une carte au hasard parmi les 4 premières cartes de la pile centrale pour la rendre visible\n    const indexCarteVisible = 3;//Math.floor(Math.random() * 4);\n    pileCentrale.cartes[indexCarteVisible].faceVisible = true;\n    console.log('originalpilecentrale',pileCentrale.cartes);\n    // Mettre à jour l'état avec les nouvelles piles, la pile centrale et la carte révélée\n    setEtat((ancienEtat) => ({\n      ...ancienEtat,\n      piles,\n      pileCentrale,\n      cartesRevelees: [pileCentrale.cartes[indexCarteVisible]], // Ajouter la carte révélée\n    }));\n  };\n\n  // Fonction pour déplacer une carte dans la pile correspondante\n  /* const deplacerCarte = (carte: CarteH, indexPile: number) => {\n    console.log(\"index de la pile est \"+indexPile);\n    const nouvellesPiles = [...etat.piles];\n    const pileCentrale = [etat.pileCentrale];\n    console.log('pileCentrale',pileCentrale);\n    console.log('nouvellesPiles',nouvellesPiles);\n    console.log(carte);\n    // Vérifier si la carte peut être déplacée (par exemple, si elle est face visible)\n /*    if (!carte.faceVisible) {\n      alert(`Vous ne pouvez pas déplacer une carte face cachée ! ${indexPile}`);\n      return;\n    } */\n\n    // Ajouter la carte à la pile correspondante et la rendre face visible\n   /* nouvellesPiles[indexPile].cartes.push({ ...carte, faceVisible: true });\n\n    // Mettre à jour l'état avec les nouvelles piles et la carte révélée\n    setEtat((ancienEtat) => ({\n      ...ancienEtat,\n      piles: nouvellesPiles,\n      cartesRevelees: [...ancienEtat.cartesRevelees, carte], // Ajouter la carte aux cartes révélées\n    }));\n  }; */\n  const deplacerCarte = () => {\n    setEtat((ancienEtat) => {\n      let nouvellesPiles = [...ancienEtat.piles];\n      let nouvellePileCentrale = { ...ancienEtat.pileCentrale };\n      let carteCouranteADeplacer = nouvellesPiles[ancienEtat.pileCibleIndex].cartes.find(c => c.faceVisible) || null;\n  if(ancienEtat.pileCibleIndex === -1){\n       carteCouranteADeplacer = nouvellePileCentrale.cartes.find(c => c.faceVisible) || null;\n    }\n    \n      if (!carteCouranteADeplacer) {\n        console.log(\"Aucune carte visible à déplacer !\");\n        return ancienEtat;\n      }\n  \n      let indexPileDestination = obtenirPileCorrespondante(carteCouranteADeplacer);\n  \n      if (indexPileDestination === -1) {\n        console.log(\"Erreur : Impossible de trouver la pile correspondante !\");\n        return ancienEtat;\n      }\n  \n      nouvellesPiles[indexPileDestination].cartes.unshift({\n        ...carteCouranteADeplacer,\n        faceVisible: true,\n      });\n  \n      nouvellePileCentrale.cartes = nouvellePileCentrale.cartes.filter(c => c.code !== carteCouranteADeplacer!.code);\n  \n      const pileCible = nouvellesPiles[indexPileDestination];\n  \n      pileCible.cartes.forEach((carte, index) => {\n        carte.faceVisible = index === 0 || index === 4;\n      });\n  \n      return {\n        ...ancienEtat,\n        piles: nouvellesPiles,\n        pileCentrale: nouvellePileCentrale,\n        cartesRevelees: [...ancienEtat.cartesRevelees, carteCouranteADeplacer],\n        pileCibleIndex: indexPileDestination, // Enregistrer l'index de la pile cible\n      };\n    });\n  };\n  \n  const deplacerCarteSuivante = () => {\n    setEtat((ancienEtat) => {\n      let nouvellesPiles = [...ancienEtat.piles];\n      const pileCible = nouvellesPiles[ancienEtat.pileCibleIndex];\n      const carteVisible = pileCible.cartes.find(c => c.faceVisible);\n  \n      if (!carteVisible) {\n        console.log(\"Aucune carte visible à déplacer dans la pile cible !\");\n        return ancienEtat;\n      }\n  \n      let indexPileDestination = obtenirPileCorrespondante(carteVisible);\n  \n      if (indexPileDestination === -1) {\n        console.log(\"Erreur : Impossible de trouver la pile correspondante pour la carte visible !\");\n        return ancienEtat;\n      }\n  \n      nouvellesPiles[indexPileDestination].cartes.unshift({\n        ...carteVisible,\n        faceVisible: true,\n      });\n  \n      pileCible.cartes = pileCible.cartes.filter(c => c.code !== carteVisible.code);\n  \n      return {\n        ...ancienEtat,\n        piles: nouvellesPiles,\n      };\n    });\n  };\n  \n  \n  \n\n  // Fonction pour obtenir l'index de la pile correspondant à une carte\n  const obtenirPileCorrespondante = (carte: CarteH) => {\n    const valeurCarte = carte.value; // Extrait la valeur de la carte (par exemple \"2\", \"JACK\", etc.)\n    console.log(valeurCarte);\n    const rangs: { [key: string]: number } = {\n      \"2\": 2,\n      \"3\": 3,\n      \"4\": 4,\n      \"5\": 5,\n      \"6\": 6,\n      \"7\": 7,\n      \"8\": 8,\n      \"9\": 9,\n      \"10\": 10,\n      \"JACK\": 11,\n      \"QUEEN\": 0,\n      \"KING\": -1,\n      \"ACE\": 1,\n    };\n    console.log(rangs[valeurCarte] ?? -1);\n    return rangs[valeurCarte] ?? -1; // Retourne l'index de la pile correspondant au rang\n  };\n\n  return (\n    <div className=\"container text-center mt-5\">\n      <h1>Clock Solitaire</h1>\n      <div\n        className=\"position-relative\"\n        style={{ width: \"500px\", height: \"500px\", margin: \"0 auto\" }}\n      >\n        {etat.piles.map((pile, index) => {\n          const angle = ((index -3)*30) * (Math.PI / 180);\n          const radius = 180;\n          const x = 250 + radius * Math.cos(angle);\n          const y = 250 + radius * Math.sin(angle);\n          return (\n            <div\n              key={index}\n              className=\"position-absolute\"\n              style={{\n                left: `${x}px`,\n                top: `${y}px`,\n                transform: \"translate(-50%, -50%)\",\n              }}\n            >\n              <PileHorloge\n                pile={pile.cartes}\n                indexPile={index}\n                deplacerCarte={deplacerCarte}\n                centrale={false}\n              />\n            </div>\n          );\n        })}\n        <div className=\"position-absolute top-50 start-50 translate-middle\">\n          <PileHorloge\n            pile={etat.pileCentrale.cartes}\n            indexPile={-1}\n            deplacerCarte={deplacerCarte}\n            centrale={true}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Horloge;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}